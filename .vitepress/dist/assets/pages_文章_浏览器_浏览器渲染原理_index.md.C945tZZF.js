import{_ as t,c as e,a1 as l,o as i}from"./chunks/framework.clinZALv.js";const m=JSON.parse('{"title":"浏览器解析并渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"pages/文章/浏览器/浏览器渲染原理/index.md","filePath":"pages/文章/浏览器/浏览器渲染原理/index.md"}'),r={name:"pages/文章/浏览器/浏览器渲染原理/index.md"};function o(s,a,n,h,d,c){return i(),e("div",null,a[0]||(a[0]=[l('<h1 id="浏览器解析并渲染原理" tabindex="-1">浏览器解析并渲染原理 <a class="header-anchor" href="#浏览器解析并渲染原理" aria-label="Permalink to &quot;浏览器解析并渲染原理&quot;">​</a></h1><img src="http://zhongxk.com/blogImg/浏览器解析并渲染流程.png" title="渲染流程图" alt="渲染流程图" width="802px" style="max-width:none;"><h2 id="_1-解析html" tabindex="-1">1.解析HTML <a class="header-anchor" href="#_1-解析html" aria-label="Permalink to &quot;1.解析HTML&quot;">​</a></h2><p>浏览器将服务器返回的数据解析成上面的DOM结构，开始逐行解析。</p><h2 id="_2-解析cssom" tabindex="-1">2.解析CSSOM <a class="header-anchor" href="#_2-解析cssom" aria-label="Permalink to &quot;2.解析CSSOM&quot;">​</a></h2><p>解析到<link>标签，下载css文件，解析CSS文件构建CSSOM，继续解析DOM</p><h2 id="_3-script-标签" tabindex="-1">3.&lt;script&gt; 标签 <a class="header-anchor" href="#_3-script-标签" aria-label="Permalink to &quot;3.\\&lt;script\\&gt; 标签&quot;">​</a></h2><p>遇到&lt;script&gt;标签，下载JS文件，执行JS，这时会阻塞解析DOM和CSSOM</p><h2 id="_4-结合渲染树" tabindex="-1">4.结合渲染树 <a class="header-anchor" href="#_4-结合渲染树" aria-label="Permalink to &quot;4.结合渲染树&quot;">​</a></h2><p>完成构建DOM树和CSSOM树后，两者结合成渲染树，不需要显示的元素如设置<strong>display:none</strong>的元素和&lt;head&gt;等标签不会在渲染树。</p><h2 id="_5-计算元素几何信息" tabindex="-1">5.计算元素几何信息 <a class="header-anchor" href="#_5-计算元素几何信息" aria-label="Permalink to &quot;5.计算元素几何信息&quot;">​</a></h2><p>首次渲染之前，需要计算元素的大小、位置等信息，为了确定每个元素的大小和位置，浏览器会从渲染树的根节点开始遍历。 第一次确定节点大小和位置称为布局，随后对节点大小和位置重新计算称为重排</p><h2 id="_6-绘制" tabindex="-1">6.绘制 <a class="header-anchor" href="#_6-绘制" aria-label="Permalink to &quot;6.绘制&quot;">​</a></h2><p>在绘制或光栅化阶段，浏览器将在布局阶段计算每个盒子转换为屏幕的实际像素 为了确保重绘能够比初始绘制更快地完成，会知道屏幕的操作被分解成几个图层 分层确实可以提高效率，但是同时也牺牲了内存</p><h2 id="_7-合成" tabindex="-1">7.合成 <a class="header-anchor" href="#_7-合成" aria-label="Permalink to &quot;7.合成&quot;">​</a></h2><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>通过上面的流程，我们可以从不同阶段进行优化</p><ol><li>减少重排重绘</li></ol><ul><li>动画尽量使用transforom</li><li>canvas离屏</li><li>&lt;img /&gt;标签固定宽高</li><li>避免使用&lt;table &gt;，因为 table 会等到它的 dom 树全部生成后再一次性插入页面中，而导致重排</li><li>使用防抖</li></ul><ol start="2"><li>优化渲染</li></ol><ul><li>&lt;script &gt;标签放在body后面，尽量不要写内联逻辑，防止阻塞DOM解析</li><li>按需加载、预加载、懒加载</li><li>css雪碧图</li><li>骨架屏</li></ul>',21)]))}const u=t(r,[["render",o]]);export{m as __pageData,u as default};
