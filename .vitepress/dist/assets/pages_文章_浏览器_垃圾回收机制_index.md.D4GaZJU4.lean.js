import{_ as e,c as l,a2 as i,o as t}from"./chunks/framework.GXDt-Def.js";const u=JSON.parse('{"title":"垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"pages/文章/浏览器/垃圾回收机制/index.md","filePath":"pages/文章/浏览器/垃圾回收机制/index.md"}'),r={name:"pages/文章/浏览器/垃圾回收机制/index.md"};function o(n,a,p,s,d,h){return t(),l("div",null,a[0]||(a[0]=[i('<h1 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-label="Permalink to &quot;垃圾回收机制&quot;">​</a></h1><h2 id="什么是垃圾" tabindex="-1">什么是垃圾 <a class="header-anchor" href="#什么是垃圾" aria-label="Permalink to &quot;什么是垃圾&quot;">​</a></h2><p>在编程语言中，用不到的对象和不再使用的对象称为垃圾</p><h2 id="为什么要回收" tabindex="-1">为什么要回收 <a class="header-anchor" href="#为什么要回收" aria-label="Permalink to &quot;为什么要回收&quot;">​</a></h2><p>定义变量时需要分配内存 而这些垃圾对象还占用着内存空间，回收实际上就是回收内存空间，如果不及时回收，会导致内存泄漏</p><h2 id="如何回收垃圾" tabindex="-1">如何回收垃圾 <a class="header-anchor" href="#如何回收垃圾" aria-label="Permalink to &quot;如何回收垃圾&quot;">​</a></h2><p>浏览器引擎会在一段时间内自动回收垃圾，也就是检查哪些对象不再使用。 如何检查哪些对象不再使用，有两种算法：</p><ol><li>引用计数</li><li>标记清除（目前所有浏览器都使用该算法）</li></ol><p>现在的chrome v8引擎是在标记清除基础上进行优化（分布式垃圾回收）</p><ul><li>引用计数法</li></ul><p>这是最初的垃圾收集算法，对象有没有其他对象引用到它，如果没有引用指向该对象，则该对象就被垃圾回收机制回收</p><p>缺点：1.需要使用计数器 2.循环引用</p><ul><li>标记清除法</li></ul><p>步骤：</p><ol><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li><li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li></ol><p>缺点：出现内存碎片</p><p>导致内存碎片是因为剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题</p><h2 id="v8对gc的优化" tabindex="-1">v8对GC的优化 <a class="header-anchor" href="#v8对gc的优化" aria-label="Permalink to &quot;v8对GC的优化&quot;">​</a></h2><p><strong>分布式垃圾回收</strong></p><ul><li>新老生代</li></ul><p>将堆内存分为新老生代区域</p><h2 id="手动设置" tabindex="-1">手动设置 <a class="header-anchor" href="#手动设置" aria-label="Permalink to &quot;手动设置&quot;">​</a></h2><ol><li>将对象设置为null</li><li>使用<strong>delete</strong></li></ol>',23)]))}const m=e(r,[["render",o]]);export{u as __pageData,m as default};
