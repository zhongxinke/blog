import{_ as l,c as p,a2 as a,j as t,a as i,G as e,w as h,B as k,o}from"./chunks/framework.CEODKeqH.js";const b=JSON.parse('{"title":"执行环境和作用域链","description":"","frontmatter":{},"headers":[],"relativePath":"pages/文章/JS/执行环境和作用域链/index.md","filePath":"pages/文章/JS/执行环境和作用域链/index.md"}'),r={name:"pages/文章/JS/执行环境和作用域链/index.md"};function d(c,s,g,E,u,y){const n=k("font");return o(),p("div",null,[s[3]||(s[3]=a(`<h1 id="执行环境和作用域链" tabindex="-1">执行环境和作用域链 <a class="header-anchor" href="#执行环境和作用域链" aria-label="Permalink to &quot;执行环境和作用域链&quot;">​</a></h1><h2 id="执行环境-执行上下文" tabindex="-1">执行环境（执行上下文） <a class="header-anchor" href="#执行环境-执行上下文" aria-label="Permalink to &quot;执行环境（执行上下文）&quot;">​</a></h2><p>执行上下文是 JavaScript 代码在运行时所需的环境。每当函数调用、代码块执行或全局代码运行时，都会创建一个新的执行上下文。执行上下文分为三种类型：</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>Eval执行上下文</li></ul><p>执行上下文包含了三个重要的属性：</p><ol><li>变量对象</li><li>作用域链</li><li>this绑定</li></ol><p>用伪代码表示</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Context {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    VariableObject {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        arguments</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 函数的arguments</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        variable </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 变量声明</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        function</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 函数声明</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ScopeChain</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ThisBind</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>创建执行上下文</strong></p><p>执行函数时会创建执行上下文，执行上下文的生命周期：</p><ol><li><em>创建阶段</em>：</li></ol><ul><li>变量对象</li><li>建立作用域链</li><li>绑定this</li></ul><ol start="2"><li><em>执行阶段</em>：</li></ol><ul><li>变量赋值</li><li>执行代码</li></ul><p><strong>执行栈</strong></p><p>每个函数都有自己的执行环境，当执行流进入一个函数时，会创建一个函数执行环境，并将环境推入到一个栈中，而这个函数执行完成之后，栈将其环境弹出，把控制权返回个之前的执行环境。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><img src="http://zhongxk.com/blogImg/执行栈.png" title="执行栈" alt="执行栈" width="700px" style="max-width:none;"><p><strong>作用域链</strong></p>`,19)),t("p",null,[s[1]||(s[1]=i("作用域链是保证执行上下文有权访问的所有变量和函数的有序访问。在创建函数时，会创建一个预先包含变量对象的作用域链，这个作用域链保存在内部的")),e(n,{color:"green"},{default:h(()=>s[0]||(s[0]=[i("[[Scope]]")])),_:1}),s[2]||(s[2]=i("属性中"))]),s[4]||(s[4]=a(`<p>以second方法为例：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[[Scope]]: [</span></span>
<span class="line"><span>    second的变量对象,</span></span>
<span class="line"><span>    first的变量对象,</span></span>
<span class="line"><span>    全局的变量对象</span></span>
<span class="line"><span>]</span></span></code></pre></div><p>这就是为什么，在一个函数内，可以访问外部函数的变量</p>`,3))])}const v=l(r,[["render",d]]);export{b as __pageData,v as default};
