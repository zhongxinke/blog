import{_ as t,c as i,a2 as a,o as e}from"./chunks/framework.CEODKeqH.js";const m=JSON.parse('{"title":"HTTPS","description":"","frontmatter":{},"headers":[],"relativePath":"pages/文章/计算机网络/Https/index.md","filePath":"pages/文章/计算机网络/Https/index.md"}'),o={name:"pages/文章/计算机网络/Https/index.md"};function s(r,l,n,h,d,c){return e(),i("div",null,l[0]||(l[0]=[a('<h1 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h1><h2 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h2><img src="http://zhongxk.com/blogImg/对称加密.png" title="对称加密" alt="对称加密"><ol><li>客户端首先发送hello请求，并将可支持的tls版本和加密算法列表发送给服务器。</li><li>服务器收到hello请求后，选择一个可支持的tls版本和加密算法，并将信息发送给客户端。</li><li>客户端收到服务器的信息后，生成一个随机字符串，并使用加密函数和算法对随机字符串进行加密，此时生成了会话密钥，然后将随机字符串发送给服务器。</li><li>服务端接收到随机字符串后，使用同样的加密函数和算法进行加密，生成与客服端一致的会话密钥</li><li>客户端和服务端都使用会话密钥进行加密解密通信。</li></ol><h2 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h2><img src="http://zhongxk.com/blogImg/非对称加密.png" title="非对称加密" alt="非对称加密"><ol><li>客户端首先发送hello请求，并将可支持的tls版本和加密算法列表发送给服务器。、</li><li>服务器收到hello请求后，选择一个可支持的tls版本和加密算法，并将信息发送给客户端，此外还会将公钥发送给客户端。</li><li>客户端收到服务器的信息后，生成一个随机字符串，并使用接收到的公钥进行加密，再将其传递给服务端。</li><li>服务器端接收到加密后的预主密钥后，使用自己的私钥进行解密，得到与客户端一致的预主密钥。</li><li>客户端和服务端都使用预主密钥进行加密解密通信。</li></ol><h2 id="完整过程-tls握手" tabindex="-1">完整过程（TLS握手） <a class="header-anchor" href="#完整过程-tls握手" aria-label="Permalink to &quot;完整过程（TLS握手）&quot;">​</a></h2><ol><li>首先客服端发送请求，并通过TCP/IP协议与服务端建立连接。</li><li>客户端发送hello请求，并选择可支持的tls版本和加密算法。</li><li>服务器收到hello请求后，选择一个可支持的tls版本和加密算法，并将信息发送给客户端，此外还会发送证书发送给客户端。</li><li>客户端收到证书后，验证证书的合法性，验证成功后，从证书中提取出服务器端的公钥。</li><li>客户端生成预主密钥，并使用服务器端的公钥进行加密，将加密后的预主密钥发送给服务端。</li><li>服务端接收到加密后的预主密钥后，使用自己的私钥进行解密，得到与客户端一致的预主密钥。</li><li>客户端和服务端都使用预主密钥进行加密解密通信。</li></ol>',9)]))}const g=t(o,[["render",s]]);export{m as __pageData,g as default};
