import{_ as s,c as a,a2 as t,o as e}from"./chunks/framework.CEODKeqH.js";const c=JSON.parse('{"title":"Javascript的执行机制","description":"","frontmatter":{},"headers":[],"relativePath":"pages/文章/JS/执行机制/index.md","filePath":"pages/文章/JS/执行机制/index.md"}'),n={name:"pages/文章/JS/执行机制/index.md"};function l(p,i,h,r,k,o){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="javascript的执行机制" tabindex="-1">Javascript的执行机制 <a class="header-anchor" href="#javascript的执行机制" aria-label="Permalink to &quot;Javascript的执行机制&quot;">​</a></h1><blockquote><p><a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noreferrer">这一次，彻底弄懂 JavaScript 执行机制</a></p></blockquote><h2 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-label="Permalink to &quot;单线程&quot;">​</a></h2><p>Javascript是单线程的，这意味着它一次只能执行一个任务，通过调用栈负责管理函数调用和返回：</p><ul><li>当一个函数被调用时，它会被推入调用栈的顶部</li><li>当函数执行完毕后，它会从调用栈中弹出</li></ul><p>所以当有一个任务执行的时间很长，其他任务都要等待，就会出现卡顿或者页面空白。</p><h2 id="同步和异步任务" tabindex="-1">同步和异步任务 <a class="header-anchor" href="#同步和异步任务" aria-label="Permalink to &quot;同步和异步任务&quot;">​</a></h2><p>将任务分为：</p><ul><li>同步</li><li>异步</li></ul><p>同步任务进入主线程，将异步任务保存到任务队列。当调用栈为空时，查看任务队列是否有任务</p><h2 id="任务队列" tabindex="-1">任务队列 <a class="header-anchor" href="#任务队列" aria-label="Permalink to &quot;任务队列&quot;">​</a></h2><p>任务队列里的任务还可以再细分：</p><ul><li>宏任务：setTimeout、setInterval、I/O操作等</li><li>微任务：Promise.then、MutationObserver、process.nextTick</li></ul><p><strong>微任务的优先级高于宏任务</strong></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在执行调用栈中的任务时，当调用栈为空后，JavaScript 引擎会检查任务队列是否有任务。如果有任务，事件循环会优先执行微任务队列中的任务，再执行宏任务队列中的任务。JavaScript 引擎的监控进程（monitoring process）会不断重复这个检查和执行的过程，这个过程就称为事件循环。</p><p><strong>用一个例子来验证</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个例子的结果是打印了10次10。我们用事件循环机制来解释这个问题。</p><p>这里的for循环进入主线程，每执行一次循环，都有 i++ 和 setTimeout。</p><p>所以每次循环，都有一个setTimeout进入任务队列，当循环结束之后，调用栈为空，任务队列里有10个宏任务</p><p>然后执行任务队列的所有任务，此时i为10，执行console.log(i)，结果就是打印了10次10</p>`,22)]))}const E=s(n,[["render",l]]);export{c as __pageData,E as default};
